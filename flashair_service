#!/usr/bin/python3

import argparse, time, urllib.request, sys, csv, datetime, sqlite3
from os.path import expanduser, exists, basename, dirname
from os import makedirs
from subprocess import run, DEVNULL, STDOUT, PIPE
from sys import exit
from shutil import which, move


parser = argparse.ArgumentParser()
parser.add_argument("-f", "--flashair-ip", default="flashair.local")
#parser.add_argument("-t", "--ping-timeout", type=int, default=5)
parser.add_argument("-s", "--source-folder", default=["/DCIM"], action='append')
parser.add_argument("-d", "--dest-folder", default=expanduser("~/FlashAir"))
parser.add_argument("-v", "--verbosity", help="increase output verbosity", action="count", default=0)
parser.add_argument("--daemon", help="Run in a continuous loop", action="store_true")
parser.add_argument("-i", "--interval", type=int, help="Seconds to wait between attemps if running as daemon", default=30)
args = parser.parse_args()

# default level for non-daemon is 1
if not args.daemon:
    args.verbosity += 1

def debug(message, level=1):
    if level <= args.verbosity:
        print(message)

debug(args, 3)


#timezone
tz = datetime.timezone.utc

#csv
csvFileListFields = ['dir', 'name', 'size', 'attr', 'date', 'time']

#sqlite transferred db
makedirs(args.dest_folder, exist_ok=True)
conn = sqlite3.connect(args.dest_folder + "/.transferred.db")
conn.execute("""CREATE TABLE IF NOT EXISTS  transferred ( 
    file TEXT NOT NULL,
    timestamp DATETIME NOT NULL,
    PRIMARY KEY (file, timestamp)
    );""")
cursor = conn.cursor()


# Find commands
jhead = which("jhead")
exiftool = which("exiftool")
fping = which("fping")
if fping:
    ping = [fping, "-r 0", args.flashair_ip]
else:
    ping = [which("ping"), "-c 1", args.flashair_ip]



def alive():
    return (run(ping, stdout=DEVNULL, stderr=STDOUT).returncode == 0)

def faCommand(encoded_url, data=None):
    command = "http://" + args.flashair_ip + "/" + encoded_url
    debug("Sending: " + command, 2)
    try:
        reader = urllib.request.urlopen(command)
    except Exception:
        pass
        raise Exception("Command Failed")

    #return data
    data = reader.read().decode('utf-8')
    #print(data)
    return data

def faTimeZone():
    try:
        data = faCommand("command.cgi?op=221")
    except Exception:
        return datetime.timezone.utc
    delta = datetime.timedelta(minutes=int(data)*15)
    return datetime.timezone(delta)


def faUsed():
    data = faCommand("command.cgi?op=140")
    sectors,bytes_per = data.split(",")
    used,total = sectors.split("/")
    return {'perc' : used/total, 'used' : used*bytes_per, 'total' : total*bytes_per}


def faUpdated():
    return faCommand("command.cgi?op=102") == "1"

def faList(dir="/"):
    data = []
    try:
        raw = faCommand("command.cgi?op=100&DIR=" + dir)
        lines = raw.splitlines()
        first = lines.pop(0)
        if first != "WLANSD_FILELIST":
            raise Exception("Invalid file list data")

        reader = csv.DictReader(lines, csvFileListFields)
        data = list(reader)
        return data
    except urllib.error.HTTPError as e:
        if "HTTP Error 404" in str(e):
            raise FileNotFoundError(str(e))

def parseDate(data):
    data = int(data)
    day = (data & 0b0000000000011111);
    month = (data & 0b0000000111100000) >> 5;
    year= ((data & 0b1111111000000000) >> 9) + 1980;
    return datetime.date(year, month, day)

def parseTime(data):
    data = int(data)
    seconds = (data & 0b0000000000011111) * 2;
    minutes = (data & 0b0000011111100000) >> 5;
    hours = (data & 0b1111100000000000) >> 11;
    return datetime.time(hours, minutes, seconds, 0, tz)

def destName(file):
    if 'dest_path' in file:
        return file['dest_path']
    
    base = file['dir'].strip("/")
    return args.dest_folder.rstrip("/") + "/" + base + "/" + file['name']

def checkDownloaded(file):
    cursor.execute("SELECT * FROM transferred WHERE file=? AND timestamp=?", (file['src_path'], file['datetime'].timestamp()))
    if cursor.fetchone() is None:
        if exists(file['dest_path']):
            raise FileExistsError(file['dest_path'] + " exists.")
        return False
    return True

def rotateFile(filename):
    if jhead:
        debug("Automatically correcting orientation", 2)
        proc = run([jhead, "-autorot", "-ft", filename], stdout=DEVNULL, stderr=STDOUT)
        debug(" ".join(proc.args), 3)
        return True

def renameFile(file):
    if exiftool:
        debug("Renaming file based on exif data", 2)
        proc = run([exiftool, "-p", "$DateTimeOriginal", "-d", "/%Y-%m/%Y-%m_%d-%H:%M:%S_", file['dest_path']], stdout=PIPE, stderr=DEVNULL)
        debug(format(proc), 3)
        dest = args.dest_folder + proc.stdout.decode().strip() + file['name']

    else:
        debug("Renaming file based on file creation date", 2)
        dest = args.dest_folder + file['datetime'].strftime("/%Y-%m/%Y-%m-%d_%H:%M:%S_") + file['name']

    makedirs(dirname(dest), exist_ok=True)
    move(file['dest_path'], dest)
    return dest

def syncFile(file):
    src = "http://" + args.flashair_ip + file['src_path']
    dst = file['dest_path']

    try:
        if not checkDownloaded(file):
            debug(file, 2)
            urllib.request.urlretrieve(src, dst)
            debug("Inserting into transferred db: " + file['src_path'] + " " + str(file['datetime'].timestamp()), 2)
            cursor.execute("INSERT INTO transferred values(?,?)", (file['src_path'], int(file['datetime'].timestamp())))
            debug("Inserted: " + str(cursor.lastrowid), 3)
            rotateFile(file['dest_path'])
            file['final_path'] = renameFile(file)
            print("Transferred file: " + file['src_path'] + " to " + file['final_path'])
                
    except FileExistsError as e:
        debug(str(e))
        


def syncDir(dir):
    files = faList(dir)
    debug(files, 4)
    
    for file in files:
        file['src_path'] = file['dir'].rstrip("/") + "/" + file['name']
        if int(file['attr']) & 16:
            # bit 5 = dir, recurse into dir
            dst_dir = args.dest_folder + "/" + file['src_path'].strip("/")
            debug("Making directory: " + dst_dir, 2)
            makedirs(dst_dir, exist_ok=True)
            syncDir(file['src_path'])
            continue
        file['dest_path'] = destName(file)
        file['datetime'] = datetime.datetime.combine(parseDate(file['date']), parseTime(file['time']))

        syncFile(file)

print("Starting " + basename(__file__) + "...")
print("Syncing " + str(args.source_folder) + " from " + args.flashair_ip)

while True:
    if alive():
        debug("FlashAir card found!")
#        if faUpdated():
#            tz = faTimeZone()


        for folder in args.source_folder:
            syncDir(folder)

    elif not args.daemon:
        # don't spam the logs when daemonized, but be friendly to humans
        print("Could not reach FlashAir card: " + args.flashair_ip)


    # only run once by default, if --daemon loop
    if not args.daemon:
        break

    # wait so we don't monopolize the CPU
    time.sleep(args.interval)

# save sqlite and close
conn.commit()
conn.close()

